#!/usr/bin/env node

/**
 * Module dependencies.
 */

var greenlock = require('../greenlock-express').create({
  // Let's Encrypt v2 is ACME draft 11
  // Note: If at first you don't succeed, stop and switch to staging
  // https://acme-staging-v02.api.letsencrypt.org/directory
  server: 'https://acme-stage-v02.api.letsencrypt.org/directory'   // acme-stage-v02
, version: 'draft-11'
  // You MUST have write access to save certs (taken care of in the docker file)
, configDir: './certs/'

// The previous 'simple' example set these values statically,
// but this example uses approveDomains() to set them dynamically
//, email: 'none@see.note.above'
//, agreeTos: false

  // approveDomains is the right place to check a database for
  // email addresses with domains and agreements and such
, approveDomains: approveDomains

, app: require('../app')

  // Get notified of important updates and help me make greenlock better
, communityMember: true

, debug: true

});

//
// My Secure Database Check
//
function approveDomains(opts, certs, cb) {

  // Only one domain is listed with *automatic* registration via SNI
  // (it's an array because managed registration allows for multiple domains,
  //                                which was the case in the simple example)
  console.log(opts.domains);

  // The domains being approved for the first time are listed in opts.domains
  // Certs being renewed are listed in certs.altnames
  if (certs) {
    opts.domains = [certs.subject].concat(certs.altnames);
  }

  fooCheckDb(opts.domains, function (err, agree, email) {
    if (err) { cb(err); return; }

    // Services SHOULD automatically accept the ToS and use YOUR email
    // Clients MUST NOT accept the ToS without asking the user
    opts.agreeTos = agree;
    opts.email = email;

    // NOTE: you can also change other options such as `challengeType` and `challenge`
    // (this would be helpful if you decided you wanted wildcard support as a domain altname)
    // opts.challengeType = 'http-01';
    // opts.challenge = require('le-challenge-fs').create({});

    cb(null, { options: opts, certs: certs });
  });
}

//
// My User / Domain Database
//
function fooCheckDb(domains, cb) {
  // This is an oversimplified example of how we might implement a check in
  // our database if we have different rules for different users and domains
  var domains = [ 'ofekp.dynu.net' ];
  var userEmail = 'ofekpearl@gmail.com';
  var userAgrees = true;
  var passCheck = opts.domains.every(function (domain) {
    return -1 !== domains.indexOf(domain);
  });

  if (!passCheck) {
    cb(new Error('domain not allowed'));
  } else {
    cb(null, userAgrees, userEmail);
  }
}

var server = greenlock.listen(80, 443);

//var app = require('../app');
var debug = require('debug')('home-sensei:server');
//var http = require('http');

/**
 * Get port from environment and store in Express.
 */

//var port = normalizePort(process.env.PORT || '8080');
//const host = '0.0.0.0';
//app.set('port', port);

/**
 * Create HTTP server.
 */

//var server = http.createServer(app);

/**
 * Listen on provided port, on all network interfaces.
 */

//server.listen(port, host);
server.on('error', onError);
server.on('listening', onListening);

/**
 * Normalize a port into a number, string, or false.
 */

function normalizePort(val) {
  var port = parseInt(val, 10);

  if (isNaN(port)) {
    // named pipe
    return val;
  }

  if (port >= 0) {
    // port number
    return port;
  }

  return false;
}

/**
 * Event listener for HTTP server "error" event.
 */

function onError(error) {
  if (error.syscall !== 'listen') {
    throw error;
  }

  var bind = typeof port === 'string'
    ? 'Pipe ' + port
    : 'Port ' + port;

  // handle specific listen errors with friendly messages
  switch (error.code) {
    case 'EACCES':
      console.error(bind + ' requires elevated privileges');
      process.exit(1);
      break;
    case 'EADDRINUSE':
      console.error(bind + ' is already in use');
      process.exit(1);
      break;
    default:
      throw error;
  }
}

/**
 * Event listener for HTTP server "listening" event.
 */

function onListening() {
  var addr = server.address();
  var bind = typeof addr === 'string'
    ? 'pipe ' + addr
    : 'port ' + addr.port;
  debug('Listening on ' + bind);
}
